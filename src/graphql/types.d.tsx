import gql from 'graphql-tag';
import * as ApolloReactCommon from '@apollo/react-common';
import * as ApolloReactHooks from '@apollo/react-hooks';
export type Maybe<T> = T | null;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** An ISO 8601-encoded datetime */
  ISO8601DateTime: any;
  /** 正の整数 */
  PositiveNumber: any;
  /** Table id, hex Timestamp, ID */
  TTID: any;
};

/** Autogenerated input type of AddPlaylistItems */
export type AddPlaylistItemsInput = {
  /** プレイリストID */
  playlistId: Scalars['TTID'];
  /** 追加したい曲ID */
  trackIds: Array<Scalars['TTID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of AddPlaylistItems */
export type AddPlaylistItemsPayload = {
   __typename?: 'AddPlaylistItemsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  /** 曲追加されたプレイリスト */
  playlist?: Maybe<Playlist>;
};

/** アルバム */
export type Album = {
   __typename?: 'Album';
  /** Apple Music アルバム */
  appleMusicAlbum?: Maybe<AppleMusicAlbum>;
  /** 大型アートワーク */
  artworkL: Artwork;
  /** 中型アートワーク */
  artworkM: Artwork;
  /** コピーライト */
  copyright: Scalars['String'];
  /** 追加日 */
  createdAt: Scalars['ISO8601DateTime'];
  /** ID */
  id: Scalars['TTID'];
  /** iTunes アルバム */
  itunesAlbum?: Maybe<AppleMusicAlbum>;
  /** タイトル */
  name: Scalars['String'];
  /** レーベル */
  recordLabel: Scalars['String'];
  /** 発売日 */
  releaseDate: Scalars['ISO8601DateTime'];
  /** Spotify アルバム */
  spotifyAlbum?: Maybe<SpotifyAlbum>;
  /** ステータス */
  status: StatusEnum;
  /** トラック数 */
  totalTracks: Scalars['PositiveNumber'];
  /** トラック */
  tracks: Array<Track>;
};

export type AlbumsConditionsInputObject = {
  /** ユーザー名 */
  usernames?: Maybe<Array<Scalars['String']>>;
  /** アーティストID */
  artists?: Maybe<IdInputObject>;
  /** トラックID */
  tracks?: Maybe<IdInputObject>;
  /** アルバム名(あいまい検索) */
  name?: Maybe<Scalars['String']>;
  /** 表示ステータス */
  status?: Maybe<Array<StatusEnum>>;
  /** お気に入り */
  favorite?: Maybe<Scalars['Boolean']>;
};

export enum AlbumsQueryOrderEnum {
  /** 追加順 */
  New = 'NEW',
  /** 発売日順 */
  Release = 'RELEASE',
  /** 人気順 */
  Popularity = 'POPULARITY'
}

export type AlbumsSortInputObject = {
  /** 並び順対象 */
  order?: Maybe<AlbumsQueryOrderEnum>;
  /** 並び順 */
  type?: Maybe<SortEnum>;
};

/** Apple Music アルバム */
export type AppleMusicAlbum = {
   __typename?: 'AppleMusicAlbum';
  /** Apple Music ID */
  appleMusicId: Scalars['String'];
  /** ID */
  id: Scalars['TTID'];
  /** タイトル */
  name: Scalars['String'];
};

/** Apple Music アーティスト */
export type AppleMusicArtist = {
   __typename?: 'AppleMusicArtist';
  /** Apple Music ID */
  appleMusicId: Scalars['String'];
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
};

/** Apple Music トラック */
export type AppleMusicTrack = {
   __typename?: 'AppleMusicTrack';
  /** Apple Music ID */
  appleMusicId: Scalars['String'];
  /** ID */
  id: Scalars['TTID'];
  /** タイトル */
  name: Scalars['String'];
};

/** アーティスト */
export type Artist = {
   __typename?: 'Artist';
  /** 関連アルバム */
  albums?: Maybe<Array<Album>>;
  /** Apple Music アーティスト */
  appleMusicArtists?: Maybe<Array<AppleMusicArtist>>;
  /** 大型アートワーク */
  artworkL: Artwork;
  /** 中型アートワーク */
  artworkM: Artwork;
  /** 追加日 */
  createdAt: Scalars['ISO8601DateTime'];
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
  /** 発売日 */
  releaseDate: Scalars['ISO8601DateTime'];
  /** Spotify アーティスト */
  spotifyArtists?: Maybe<Array<SpotifyArtist>>;
  /** ステータス */
  status: StatusEnum;
  /** 関連曲 */
  tracks?: Maybe<Array<Track>>;
};

export type ArtistsConditionsInputObject = {
  /** ユーザー名 */
  usernames?: Maybe<Array<Scalars['String']>>;
  /** アルバムID */
  albums?: Maybe<IdInputObject>;
  /** トラックID */
  tracks?: Maybe<IdInputObject>;
  /** アーティスト名(あいまい検索) */
  name?: Maybe<Scalars['String']>;
  /** 表示ステータス */
  status?: Maybe<Array<StatusEnum>>;
  /** お気に入り */
  favorite?: Maybe<Scalars['Boolean']>;
};

export enum ArtistsQueryOrderEnum {
  /** 名前順 */
  Name = 'NAME',
  /** 追加順 */
  New = 'NEW',
  /** 人気順 */
  Popularity = 'POPULARITY'
}

export type ArtistsSortInputObject = {
  /** ソート対象 */
  order?: Maybe<ArtistsQueryOrderEnum>;
  /** 並び順 */
  type?: Maybe<SortEnum>;
};

/** アートワーク */
export type Artwork = {
   __typename?: 'Artwork';
  /** 高さ */
  height?: Maybe<Scalars['PositiveNumber']>;
  /** URL */
  url?: Maybe<Scalars['String']>;
  /** 幅 */
  width?: Maybe<Scalars['PositiveNumber']>;
};

/** Autogenerated input type of ChangeFavorites */
export type ChangeFavoritesInput = {
  /** お気に入り変更したいアーティストID */
  artistIds?: Maybe<Array<Scalars['TTID']>>;
  /** お気に入り変更したいアルバムID */
  albumIds?: Maybe<Array<Scalars['TTID']>>;
  /** お気に入り変更したいトラックID */
  trackIds?: Maybe<Array<Scalars['TTID']>>;
  /** true の場合は一括でお気に入り登録をする。false 場合は一括で解除する。 */
  favorite: Scalars['Boolean'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ChangeFavorites */
export type ChangeFavoritesPayload = {
   __typename?: 'ChangeFavoritesPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  /** 更新されたカレントユーザー */
  currentUser?: Maybe<CurrentUser>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of ChangeStatus */
export type ChangeStatusInput = {
  /** 変更したいアーティストID */
  artistId?: Maybe<Scalars['TTID']>;
  /** 変更したいアルバムID */
  albumId?: Maybe<Scalars['TTID']>;
  /** 変更したいトラックID */
  trackId?: Maybe<Scalars['TTID']>;
  /** 変更したいステータス */
  status: StatusEnum;
  /** true の場合は関連のステータスは変更しない。デフォルトは false。アーティスト限定 */
  only?: Maybe<Scalars['Boolean']>;
  /** true の場合は Twitter に投稿する。デフォルトは true */
  tweet?: Maybe<Scalars['Boolean']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ChangeStatus */
export type ChangeStatusPayload = {
   __typename?: 'ChangeStatusPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  /** 変更されたステータスを持ったモデル */
  model?: Maybe<ModelHasStatusUnion>;
};

/** Autogenerated input type of ClearCache */
export type ClearCacheInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ClearCache */
export type ClearCachePayload = {
   __typename?: 'ClearCachePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  results?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of CompactAlbum */
export type CompactAlbumInput = {
  /** 統合後のアルバム名。 */
  name: Scalars['String'];
  /** 統合したいアルバムID。Apple Music アルバムのみ統合される。指定した順番通りに統合する。 */
  albumIdsForAppleMusic?: Maybe<Array<Scalars['TTID']>>;
  /** 統合したいアルバムID。Spotify アルバムのみ統合される。指定した順番通りに統合する。 */
  albumIdsForSpotify?: Maybe<Array<Scalars['TTID']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of CompactAlbum */
export type CompactAlbumPayload = {
   __typename?: 'CompactAlbumPayload';
  /** 統合されたアルバム */
  album?: Maybe<Album>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** カレントユーザー */
export type CurrentUser = {
   __typename?: 'CurrentUser';
  /** お気に入り */
  favorite: Favorite;
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
  /** 公開情報 */
  publicInformations: Array<PublicInformation>;
  /** 登録済み */
  registered: Scalars['Boolean'];
  /** ロール */
  role: Role;
  /** ユーザー名 */
  username: Scalars['String'];
  /** バージョンファイル */
  version: Scalars['String'];
};

export type CursorInputObject = {
  offset?: Maybe<Scalars['Int']>;
  limit?: Maybe<Scalars['PositiveNumber']>;
};

/** お気に入り */
export type Favorite = {
   __typename?: 'Favorite';
  /** アルバムID */
  albumIds: Array<Scalars['String']>;
  /** アーティストID */
  artistIds: Array<Scalars['String']>;
  /** トラックID */
  trackIds: Array<Scalars['String']>;
};

/** Autogenerated input type of ForceIgnoreAlbum */
export type ForceIgnoreAlbumInput = {
  /** 除外コンテンツに登録したいアルバムID */
  albumId: Scalars['TTID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of ForceIgnoreAlbum */
export type ForceIgnoreAlbumPayload = {
   __typename?: 'ForceIgnoreAlbumPayload';
  /** 除外コンテンツに登録されたアルバム */
  album?: Maybe<Album>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of GenerateSitemaps */
export type GenerateSitemapsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of GenerateSitemaps */
export type GenerateSitemapsPayload = {
   __typename?: 'GenerateSitemapsPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  results?: Maybe<Array<Scalars['String']>>;
};


export type IdInputObject = {
  /** ID */
  id?: Maybe<Array<Scalars['TTID']>>;
};

/** Autogenerated input type of IgnoreAlbums */
export type IgnoreAlbumsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of IgnoreAlbums */
export type IgnoreAlbumsPayload = {
   __typename?: 'IgnoreAlbumsPayload';
  /** IGNOREされたアルバム */
  albums?: Maybe<Array<Album>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of IgnoreArtists */
export type IgnoreArtistsInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of IgnoreArtists */
export type IgnoreArtistsPayload = {
   __typename?: 'IgnoreArtistsPayload';
  /** IGNOREされたアーティスト */
  artists?: Maybe<Array<Artist>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of Login */
export type LoginInput = {
  username: Scalars['String'];
  password: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of Login */
export type LoginPayload = {
   __typename?: 'LoginPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<CurrentUser>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of Logout */
export type LogoutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of Logout */
export type LogoutPayload = {
   __typename?: 'LogoutPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<CurrentUser>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MixAlbum */
export type MixAlbumInput = {
  /** 混合したいアルバムID */
  albumIds: Array<Scalars['TTID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of MixAlbum */
export type MixAlbumPayload = {
   __typename?: 'MixAlbumPayload';
  /** 混合されたアルバム */
  album?: Maybe<Album>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of MixArtist */
export type MixArtistInput = {
  /** メインアーティストID */
  mainArtistId: Scalars['TTID'];
  /** サブアーティストID */
  subArtistId: Scalars['TTID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of MixArtist */
export type MixArtistPayload = {
   __typename?: 'MixArtistPayload';
  /** 混合されたアーティスト */
  artist?: Maybe<Artist>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** ステータスをもつモデルのいずれか */
export type ModelHasStatusUnion = Album | Artist | Track;

export type Mutation = {
   __typename?: 'Mutation';
  /** プレイリストに曲を追加する */
  addPlaylistItems?: Maybe<AddPlaylistItemsPayload>;
  /** お気に入り一括変更 */
  changeFavorites?: Maybe<ChangeFavoritesPayload>;
  /** ステータス変更。関連するアルバム, トラック, 各音楽サービスアルバム、各音楽サービストラックも同じステータスで更新される。 */
  changeStatus?: Maybe<ChangeStatusPayload>;
  /** 検索結果キャッシュをリセットする */
  clearCache?: Maybe<ClearCachePayload>;
  /** 複数アルバムを単一アルバムに統合する。統合前の複数アルバムは全て IGNORE される。 */
  compactAlbum?: Maybe<CompactAlbumPayload>;
  /** 対象アルバムを除外コンテンツに登録する */
  forceIgnoreAlbum?: Maybe<ForceIgnoreAlbumPayload>;
  /** サイトマップを更新する */
  generateSitemaps?: Maybe<GenerateSitemapsPayload>;
  /** PENDING状態のアルバム全てをIGNOREにする。よく考えてから実行すること。 */
  ignoreAlbums?: Maybe<IgnoreAlbumsPayload>;
  /** PENDING状態のアーティスト全てをIGNOREにする。よく考えてから実行すること。 */
  ignoreArtists?: Maybe<IgnoreArtistsPayload>;
  /** ログイン */
  login?: Maybe<LoginPayload>;
  /** ログアウト */
  logout?: Maybe<LogoutPayload>;
  /**
   * アルバムを混合する。
   * 同じアルバムのはずが各音楽サービスで別のアルバムと認識される場合がある。
   * その場合に使用する。曲数が多いアルバムを正とする。
   */
  mixAlbum?: Maybe<MixAlbumPayload>;
  /**
   * アーティストを混合する。
   * 混合後は修正不可のため注意して使用すること。
   */
  mixArtist?: Maybe<MixArtistPayload>;
  /** サインアップ */
  signup?: Maybe<SignupPayload>;
  /** 統合したアルバムを元に戻す。統合された単一アルバムは削除される。 */
  uncompactAlbum?: Maybe<UncompactAlbumPayload>;
  /** アルバムの混合を解除する。アルバムと曲数に相違がある音楽サービスアルバムを分離する。 */
  unmixAlbum?: Maybe<UnmixAlbumPayload>;
  /** カレントユーザー情報更新 */
  updateMe?: Maybe<UpdateMePayload>;
  /** アルバムを最新の状態にする */
  upsertAlbum?: Maybe<UpsertAlbumPayload>;
  /** アーティストを最新の状態にする */
  upsertArtist?: Maybe<UpsertArtistPayload>;
  /** プレイリストを作成更新する */
  upsertPlaylist?: Maybe<UpsertPlaylistPayload>;
  /** ロールを追加更新する */
  upsertRole?: Maybe<UpsertRolePayload>;
};


export type MutationAddPlaylistItemsArgs = {
  input: AddPlaylistItemsInput;
};


export type MutationChangeFavoritesArgs = {
  input: ChangeFavoritesInput;
};


export type MutationChangeStatusArgs = {
  input: ChangeStatusInput;
};


export type MutationClearCacheArgs = {
  input: ClearCacheInput;
};


export type MutationCompactAlbumArgs = {
  input: CompactAlbumInput;
};


export type MutationForceIgnoreAlbumArgs = {
  input: ForceIgnoreAlbumInput;
};


export type MutationGenerateSitemapsArgs = {
  input: GenerateSitemapsInput;
};


export type MutationIgnoreAlbumsArgs = {
  input: IgnoreAlbumsInput;
};


export type MutationIgnoreArtistsArgs = {
  input: IgnoreArtistsInput;
};


export type MutationLoginArgs = {
  input: LoginInput;
};


export type MutationLogoutArgs = {
  input: LogoutInput;
};


export type MutationMixAlbumArgs = {
  input: MixAlbumInput;
};


export type MutationMixArtistArgs = {
  input: MixArtistInput;
};


export type MutationSignupArgs = {
  input: SignupInput;
};


export type MutationUncompactAlbumArgs = {
  input: UncompactAlbumInput;
};


export type MutationUnmixAlbumArgs = {
  input: UnmixAlbumInput;
};


export type MutationUpdateMeArgs = {
  input: UpdateMeInput;
};


export type MutationUpsertAlbumArgs = {
  input: UpsertAlbumInput;
};


export type MutationUpsertArtistArgs = {
  input: UpsertArtistInput;
};


export type MutationUpsertPlaylistArgs = {
  input: UpsertPlaylistInput;
};


export type MutationUpsertRoleArgs = {
  input: UpsertRoleInput;
};

/** プレイリスト */
export type Playlist = {
   __typename?: 'Playlist';
  /** 作者 */
  author?: Maybe<User>;
  /** 作成日 */
  createdAt: Scalars['ISO8601DateTime'];
  /** 説明 */
  description: Scalars['String'];
  /** ID */
  id: Scalars['TTID'];
  /** 曲一覧 */
  items: Array<PlaylistItem>;
  /** タイトル */
  name: Scalars['String'];
  /** 公開種別 */
  publicType: Scalars['String'];
  /** ジャケットトラック */
  track: Track;
  /** 更新日 */
  updatedAt: Scalars['ISO8601DateTime'];
};

/** プレイリストトラック */
export type PlaylistItem = {
   __typename?: 'PlaylistItem';
  /** ID */
  id: Scalars['TTID'];
  /** 曲 */
  track: Track;
  /** トラックナンバー */
  trackNumber: Scalars['Int'];
};

export enum PlaylistPublicTypeEnum {
  /** 公開 */
  Open = 'OPEN',
  /** 非公開 */
  NonOpen = 'NON_OPEN',
  /** 名前なし公開 */
  NoNameOpen = 'NO_NAME_OPEN'
}

export type PlaylistsConditionsInputObject = {
  /** プレイリスト名( like 検索) */
  name?: Maybe<Scalars['String']>;
};

export enum PlaylistsQueryOrderEnum {
  /** 作成日順 */
  New = 'NEW'
}

export type PlaylistsSortInputObject = {
  /** 並び順対象 */
  order?: Maybe<PlaylistsQueryOrderEnum>;
  /** 並び順 */
  type?: Maybe<SortEnum>;
};


/** 公開情報 */
export type PublicInformation = {
   __typename?: 'PublicInformation';
  /** ID */
  id: Scalars['TTID'];
  /** 公開タイプ */
  publicType: Scalars['String'];
};

export type Query = {
   __typename?: 'Query';
  /** アルバム情報取得 */
  album?: Maybe<Album>;
  /** アルバム一覧取得 */
  albums: Array<Album>;
  /** Apple Music Token */
  appleMusicToken: Scalars['String'];
  /** アーティスト取得 */
  artist?: Maybe<Artist>;
  /** アーティスト一覧取得 */
  artists: Array<Artist>;
  /** カレントユーザー情報取得 */
  me: CurrentUser;
  /** プレイリスト取得 */
  playlist?: Maybe<Playlist>;
  /** プレイリスト一覧取得 */
  playlists: Array<Playlist>;
  /** ロール一覧取得 */
  roles: Array<Role>;
  /** Spotify Token */
  spotifyToken: SpotifyToken;
  /** トラック一覧取得 */
  tracks: Array<Track>;
};


export type QueryAlbumArgs = {
  id: Scalars['TTID'];
};


export type QueryAlbumsArgs = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<AlbumsSortInputObject>;
  conditions?: Maybe<AlbumsConditionsInputObject>;
};


export type QueryArtistArgs = {
  id: Scalars['TTID'];
};


export type QueryArtistsArgs = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<ArtistsSortInputObject>;
  conditions?: Maybe<ArtistsConditionsInputObject>;
};


export type QueryPlaylistArgs = {
  id: Scalars['TTID'];
};


export type QueryPlaylistsArgs = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<PlaylistsSortInputObject>;
  conditions?: Maybe<PlaylistsConditionsInputObject>;
};


export type QuerySpotifyTokenArgs = {
  code?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
};


export type QueryTracksArgs = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<TracksSortInputObject>;
  conditions?: Maybe<TracksConditionsInputObject>;
};

/** ロール */
export type Role = {
   __typename?: 'Role';
  /** 出来ること一覧 */
  allowedActions: Array<Scalars['String']>;
  /** 説明 */
  description: Scalars['String'];
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
};

/** Autogenerated input type of Signup */
export type SignupInput = {
  name: Scalars['String'];
  username: Scalars['String'];
  password: Scalars['String'];
  passwordConfirmation: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of Signup */
export type SignupPayload = {
   __typename?: 'SignupPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<CurrentUser>;
  error?: Maybe<Scalars['String']>;
};

export enum SortEnum {
  /** 昇順 */
  Asc = 'ASC',
  /** 降順 */
  Desc = 'DESC'
}

/** Spotify アルバム */
export type SpotifyAlbum = {
   __typename?: 'SpotifyAlbum';
  /** ID */
  id: Scalars['TTID'];
  /** タイトル */
  name: Scalars['String'];
  /** Spotify ID */
  spotifyId: Scalars['String'];
};

/** Spotify アーティスト */
export type SpotifyArtist = {
   __typename?: 'SpotifyArtist';
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
  /** Spotify ID */
  spotifyId: Scalars['String'];
};

/** Spotify Token */
export type SpotifyToken = {
   __typename?: 'SpotifyToken';
  accessToken: Scalars['String'];
  expiresIn: Scalars['Int'];
  refreshToken?: Maybe<Scalars['String']>;
  scope: Scalars['String'];
  tokenType: Scalars['String'];
};

/** Spotify トラック */
export type SpotifyTrack = {
   __typename?: 'SpotifyTrack';
  /** ID */
  id: Scalars['TTID'];
  /** タイトル */
  name: Scalars['String'];
  /** Spotify ID */
  spotifyId: Scalars['String'];
};

export enum StatusEnum {
  /** 保留 : デフォルトの検索結果に表示されない */
  Pending = 'PENDING',
  /** 有効 : 通常検索結果に表示される */
  Active = 'ACTIVE',
  /** 除外 : 検索結果から除外される。最新情報などを取得する際などでも除外される */
  Ignore = 'IGNORE'
}


/** トラック */
export type Track = {
   __typename?: 'Track';
  /** Apple Music トラック */
  appleMusicTracks?: Maybe<Array<AppleMusicTrack>>;
  /** 大型アートワーク */
  artworkL: Artwork;
  /** 中型アートワーク */
  artworkM: Artwork;
  /** ディスク番号 */
  discNumber: Scalars['PositiveNumber'];
  /** 再生時間 */
  durationMs: Scalars['PositiveNumber'];
  /** ID */
  id: Scalars['TTID'];
  /** 国際標準レコーディングコード */
  isrc: Scalars['String'];
  /** iTunes トラック */
  itunesTracks?: Maybe<Array<AppleMusicTrack>>;
  /** タイトル */
  name: Scalars['String'];
  /** 人気度 */
  popularity: Scalars['Int'];
  /** プレビューURL */
  previewUrl?: Maybe<Scalars['String']>;
  /** Spotify トラック */
  spotifyTracks?: Maybe<Array<SpotifyTrack>>;
  /** ステータス */
  status: StatusEnum;
  /** トラック番号 */
  trackNumber: Scalars['PositiveNumber'];
};

export type TracksConditionsInputObject = {
  /** トラック名(あいまい検索) */
  name?: Maybe<Scalars['String']>;
  /** 表示ステータス */
  status?: Maybe<Array<StatusEnum>>;
  /** お気に入り */
  favorite?: Maybe<Scalars['Boolean']>;
};

export enum TracksQueryOrderEnum {
  /** 名前順 */
  Name = 'NAME',
  /** 追加順 */
  New = 'NEW',
  /** 人気順 */
  Popularity = 'POPULARITY'
}

export type TracksSortInputObject = {
  /** 並び順対象 */
  order?: Maybe<TracksQueryOrderEnum>;
  /** 並び順 */
  type?: Maybe<SortEnum>;
};

/** Autogenerated input type of UncompactAlbum */
export type UncompactAlbumInput = {
  /** 統合解除したいアルバムID。Apple Music アルバムのみ解除される。 */
  albumIdForAppleMusic?: Maybe<Scalars['TTID']>;
  /** 統合解除したいアルバムID。Spotify アルバムのみ解除される。 */
  albumIdForSpotify?: Maybe<Scalars['TTID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UncompactAlbum */
export type UncompactAlbumPayload = {
   __typename?: 'UncompactAlbumPayload';
  /** 統合解除されたアルバム */
  albums?: Maybe<Array<Album>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UnmixAlbum */
export type UnmixAlbumInput = {
  /** 混合解除したいアルバムID */
  albumId: Scalars['TTID'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UnmixAlbum */
export type UnmixAlbumPayload = {
   __typename?: 'UnmixAlbumPayload';
  /** 混合されたアルバム */
  albums?: Maybe<Array<Album>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateMe */
export type UpdateMeInput = {
  name?: Maybe<Scalars['String']>;
  isPublicArtist: Scalars['Boolean'];
  isPublicAlbum: Scalars['Boolean'];
  newPassword?: Maybe<Scalars['String']>;
  passwordConfirmation?: Maybe<Scalars['String']>;
  oldPassword?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpdateMe */
export type UpdateMePayload = {
   __typename?: 'UpdateMePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  currentUser?: Maybe<CurrentUser>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpsertAlbum */
export type UpsertAlbumInput = {
  /** 指定したアルバムのトラック(ISRC)を含んでいる別音楽サービスのアルバムを一括登録 */
  albumId?: Maybe<Scalars['TTID']>;
  /** Apple Music か iTunes のアルバムを登録 */
  appleMusicId?: Maybe<Scalars['String']>;
  /** Spotify のアルバムを登録 */
  spotifyId?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertAlbum */
export type UpsertAlbumPayload = {
   __typename?: 'UpsertAlbumPayload';
  /** 追加されたアルバム */
  albums?: Maybe<Array<Album>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpsertArtist */
export type UpsertArtistInput = {
  /**
   * アーティスト名から全ての音楽サービスのアーティストを登録。登録後、関連アルバム、トラックを全て保存する。
   * (ありきたりなアーティスト名の場合は関係のないアーティストが登録される可能性があるため注意)
   */
  artistName?: Maybe<Scalars['String']>;
  /** アーティストに関連する音楽サービスアーティストを更新。関連アルバム、トラックを全て更新する。 */
  artistId?: Maybe<Scalars['String']>;
  /** Apple Music のアーティストを登録。登録後、関連アルバム、トラックを全て保存する。 */
  appleMusicId?: Maybe<Scalars['String']>;
  /** Spotify のアーティストを登録。登録後、関連アルバム、トラックを全て保存する。 */
  spotifyId?: Maybe<Scalars['String']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertArtist */
export type UpsertArtistPayload = {
   __typename?: 'UpsertArtistPayload';
  /** 追加されたアーティスト */
  artists?: Maybe<Array<Artist>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
};

/** Autogenerated input type of UpsertPlaylist */
export type UpsertPlaylistInput = {
  /** IDがない場合は作成 */
  playlistId?: Maybe<Scalars['TTID']>;
  /** ジャケットトラックID */
  trackId: Scalars['TTID'];
  /** タイトル */
  name: Scalars['String'];
  /** 説明 */
  description?: Maybe<Scalars['String']>;
  /** 公開種別 */
  publicType: PlaylistPublicTypeEnum;
  /** トラックID */
  trackIds: Array<Scalars['TTID']>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertPlaylist */
export type UpsertPlaylistPayload = {
   __typename?: 'UpsertPlaylistPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  /** 作成更新されたプレイリスト */
  playlist?: Maybe<Playlist>;
};

/** Autogenerated input type of UpsertRole */
export type UpsertRoleInput = {
  /** 変更したいロール。IDを指定しない場合は追加される */
  id?: Maybe<Scalars['TTID']>;
  /** ロール名。IDを指定しない場合は必須。 */
  name?: Maybe<Scalars['String']>;
  /** ロールの説明。IDを指定しない場合は必須。 */
  description?: Maybe<Scalars['String']>;
  /** 変更したいアクション。全て上書きされる。IDを指定しない場合は必須。 */
  allowedActions?: Maybe<Array<Scalars['String']>>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
};

/** Autogenerated return type of UpsertRole */
export type UpsertRolePayload = {
   __typename?: 'UpsertRolePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  error?: Maybe<Scalars['String']>;
  /** 追加更新されたロール */
  role?: Maybe<Role>;
};

/** ユーザー */
export type User = {
   __typename?: 'User';
  /** ID */
  id: Scalars['TTID'];
  /** 名前 */
  name: Scalars['String'];
  /** ユーザー名 */
  username: Scalars['String'];
};

export type ChangeFavoritesMutationVariables = {
  input: ChangeFavoritesInput;
};


export type ChangeFavoritesMutation = (
  { __typename?: 'Mutation' }
  & { changeFavorites?: Maybe<(
    { __typename?: 'ChangeFavoritesPayload' }
    & { currentUser?: Maybe<(
      { __typename?: 'CurrentUser' }
      & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
      & { publicInformations: Array<(
        { __typename?: 'PublicInformation' }
        & Pick<PublicInformation, 'id' | 'publicType'>
      )>, role: (
        { __typename?: 'Role' }
        & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
      ), favorite: (
        { __typename?: 'Favorite' }
        & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
      ) }
    )> }
  )> }
);

export type SpotifyTokenQueryVariables = {
  code?: Maybe<Scalars['String']>;
  refreshToken?: Maybe<Scalars['String']>;
};


export type SpotifyTokenQuery = (
  { __typename?: 'Query' }
  & { spotifyToken: (
    { __typename?: 'SpotifyToken' }
    & Pick<SpotifyToken, 'accessToken' | 'expiresIn' | 'refreshToken' | 'scope' | 'tokenType'>
  ) }
);

export type AlbumQueryVariables = {
  id: Scalars['TTID'];
};


export type AlbumQuery = (
  { __typename?: 'Query' }
  & { album?: Maybe<(
    { __typename?: 'Album' }
    & Pick<Album, 'id' | 'totalTracks' | 'name' | 'releaseDate' | 'recordLabel' | 'copyright'>
    & { artworkL: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ), artworkM: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ), appleMusicAlbum?: Maybe<(
      { __typename?: 'AppleMusicAlbum' }
      & Pick<AppleMusicAlbum, 'id' | 'appleMusicId'>
    )>, itunesAlbum?: Maybe<(
      { __typename?: 'AppleMusicAlbum' }
      & Pick<AppleMusicAlbum, 'id' | 'appleMusicId'>
    )>, spotifyAlbum?: Maybe<(
      { __typename?: 'SpotifyAlbum' }
      & Pick<SpotifyAlbum, 'id' | 'spotifyId'>
    )>, tracks: Array<(
      { __typename?: 'Track' }
      & Pick<Track, 'id' | 'isrc' | 'name' | 'discNumber' | 'trackNumber' | 'durationMs' | 'previewUrl' | 'popularity'>
      & { artworkM: (
        { __typename?: 'Artwork' }
        & Pick<Artwork, 'url' | 'width' | 'height'>
      ), appleMusicTracks?: Maybe<Array<(
        { __typename?: 'AppleMusicTrack' }
        & Pick<AppleMusicTrack, 'id' | 'name' | 'appleMusicId'>
      )>>, spotifyTracks?: Maybe<Array<(
        { __typename?: 'SpotifyTrack' }
        & Pick<SpotifyTrack, 'id' | 'name' | 'spotifyId'>
      )>> }
    )> }
  )> }
);

export type AlbumsQueryVariables = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<AlbumsSortInputObject>;
  conditions?: Maybe<AlbumsConditionsInputObject>;
};


export type AlbumsQuery = (
  { __typename?: 'Query' }
  & { items: Array<(
    { __typename?: 'Album' }
    & Pick<Album, 'id' | 'name' | 'status'>
    & { artworkM: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ), appleMusicAlbum?: Maybe<(
      { __typename?: 'AppleMusicAlbum' }
      & Pick<AppleMusicAlbum, 'id'>
    )>, itunesAlbum?: Maybe<(
      { __typename?: 'AppleMusicAlbum' }
      & Pick<AppleMusicAlbum, 'id'>
    )>, spotifyAlbum?: Maybe<(
      { __typename?: 'SpotifyAlbum' }
      & Pick<SpotifyAlbum, 'id'>
    )> }
  )> }
);

export type AppleMusicTokenQueryVariables = {};


export type AppleMusicTokenQuery = (
  { __typename?: 'Query' }
  & Pick<Query, 'appleMusicToken'>
);

export type ArtistQueryVariables = {
  id: Scalars['TTID'];
};


export type ArtistQuery = (
  { __typename?: 'Query' }
  & { artist?: Maybe<(
    { __typename?: 'Artist' }
    & Pick<Artist, 'id' | 'name'>
    & { artworkL: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ) }
  )> }
);

export type ArtistsQueryVariables = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<ArtistsSortInputObject>;
  conditions?: Maybe<ArtistsConditionsInputObject>;
};


export type ArtistsQuery = (
  { __typename?: 'Query' }
  & { items: Array<(
    { __typename?: 'Artist' }
    & Pick<Artist, 'id' | 'name' | 'status'>
    & { artworkM: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ) }
  )> }
);

export type PlaylistQueryVariables = {
  id: Scalars['TTID'];
};


export type PlaylistQuery = (
  { __typename?: 'Query' }
  & { playlist?: Maybe<(
    { __typename?: 'Playlist' }
    & Pick<Playlist, 'id' | 'name' | 'description' | 'publicType' | 'createdAt' | 'updatedAt'>
    & { track: (
      { __typename?: 'Track' }
      & Pick<Track, 'id'>
      & { artworkL: (
        { __typename?: 'Artwork' }
        & Pick<Artwork, 'url' | 'width' | 'height'>
      ) }
    ), author?: Maybe<(
      { __typename?: 'User' }
      & Pick<User, 'id' | 'name' | 'username'>
    )>, items: Array<(
      { __typename?: 'PlaylistItem' }
      & Pick<PlaylistItem, 'trackNumber'>
      & { track: (
        { __typename?: 'Track' }
        & Pick<Track, 'id' | 'isrc' | 'name' | 'discNumber' | 'trackNumber' | 'durationMs' | 'previewUrl' | 'popularity'>
        & { artworkM: (
          { __typename?: 'Artwork' }
          & Pick<Artwork, 'url' | 'width' | 'height'>
        ), appleMusicTracks?: Maybe<Array<(
          { __typename?: 'AppleMusicTrack' }
          & Pick<AppleMusicTrack, 'id' | 'name' | 'appleMusicId'>
        )>>, spotifyTracks?: Maybe<Array<(
          { __typename?: 'SpotifyTrack' }
          & Pick<SpotifyTrack, 'id' | 'name' | 'spotifyId'>
        )>> }
      ) }
    )> }
  )> }
);

export type PlaylistsQueryVariables = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<PlaylistsSortInputObject>;
  conditions?: Maybe<PlaylistsConditionsInputObject>;
};


export type PlaylistsQuery = (
  { __typename?: 'Query' }
  & { items: Array<(
    { __typename?: 'Playlist' }
    & Pick<Playlist, 'id' | 'name' | 'createdAt' | 'updatedAt'>
    & { track: (
      { __typename?: 'Track' }
      & Pick<Track, 'id'>
      & { artworkM: (
        { __typename?: 'Artwork' }
        & Pick<Artwork, 'url' | 'width' | 'height'>
      ) }
    ), author?: Maybe<(
      { __typename?: 'User' }
      & Pick<User, 'id' | 'name'>
    )> }
  )> }
);

export type TracksQueryVariables = {
  cursor?: Maybe<CursorInputObject>;
  sort?: Maybe<TracksSortInputObject>;
  conditions?: Maybe<TracksConditionsInputObject>;
};


export type TracksQuery = (
  { __typename?: 'Query' }
  & { items: Array<(
    { __typename?: 'Track' }
    & Pick<Track, 'id' | 'isrc' | 'name' | 'discNumber' | 'trackNumber' | 'durationMs' | 'previewUrl' | 'popularity'>
    & { appleMusicTracks?: Maybe<Array<(
      { __typename?: 'AppleMusicTrack' }
      & Pick<AppleMusicTrack, 'id'>
    )>>, itunesTracks?: Maybe<Array<(
      { __typename?: 'AppleMusicTrack' }
      & Pick<AppleMusicTrack, 'id'>
    )>>, spotifyTracks?: Maybe<Array<(
      { __typename?: 'SpotifyTrack' }
      & Pick<SpotifyTrack, 'id'>
    )>>, artworkM: (
      { __typename?: 'Artwork' }
      & Pick<Artwork, 'url' | 'width' | 'height'>
    ) }
  )> }
);

export type LoginMutationVariables = {
  input: LoginInput;
};


export type LoginMutation = (
  { __typename?: 'Mutation' }
  & { login?: Maybe<(
    { __typename?: 'LoginPayload' }
    & Pick<LoginPayload, 'error'>
    & { currentUser?: Maybe<(
      { __typename?: 'CurrentUser' }
      & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
      & { publicInformations: Array<(
        { __typename?: 'PublicInformation' }
        & Pick<PublicInformation, 'id' | 'publicType'>
      )>, role: (
        { __typename?: 'Role' }
        & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
      ), favorite: (
        { __typename?: 'Favorite' }
        & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
      ) }
    )> }
  )> }
);

export type LogoutMutationVariables = {
  input: LogoutInput;
};


export type LogoutMutation = (
  { __typename?: 'Mutation' }
  & { logout?: Maybe<(
    { __typename?: 'LogoutPayload' }
    & Pick<LogoutPayload, 'error'>
    & { currentUser?: Maybe<(
      { __typename?: 'CurrentUser' }
      & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
      & { publicInformations: Array<(
        { __typename?: 'PublicInformation' }
        & Pick<PublicInformation, 'id' | 'publicType'>
      )>, role: (
        { __typename?: 'Role' }
        & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
      ), favorite: (
        { __typename?: 'Favorite' }
        & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
      ) }
    )> }
  )> }
);

export type MeQueryVariables = {};


export type MeQuery = (
  { __typename?: 'Query' }
  & { me: (
    { __typename?: 'CurrentUser' }
    & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
    & { publicInformations: Array<(
      { __typename?: 'PublicInformation' }
      & Pick<PublicInformation, 'id' | 'publicType'>
    )>, role: (
      { __typename?: 'Role' }
      & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
    ), favorite: (
      { __typename?: 'Favorite' }
      & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
    ) }
  ) }
);

export type UpdateMeMutationVariables = {
  input: UpdateMeInput;
};


export type UpdateMeMutation = (
  { __typename?: 'Mutation' }
  & { updateMe?: Maybe<(
    { __typename?: 'UpdateMePayload' }
    & Pick<UpdateMePayload, 'error'>
    & { currentUser?: Maybe<(
      { __typename?: 'CurrentUser' }
      & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
      & { publicInformations: Array<(
        { __typename?: 'PublicInformation' }
        & Pick<PublicInformation, 'id' | 'publicType'>
      )>, role: (
        { __typename?: 'Role' }
        & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
      ), favorite: (
        { __typename?: 'Favorite' }
        & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
      ) }
    )> }
  )> }
);

export type SignupMutationVariables = {
  input: SignupInput;
};


export type SignupMutation = (
  { __typename?: 'Mutation' }
  & { signup?: Maybe<(
    { __typename?: 'SignupPayload' }
    & Pick<SignupPayload, 'error'>
    & { currentUser?: Maybe<(
      { __typename?: 'CurrentUser' }
      & Pick<CurrentUser, 'id' | 'name' | 'username' | 'registered' | 'version'>
      & { publicInformations: Array<(
        { __typename?: 'PublicInformation' }
        & Pick<PublicInformation, 'id' | 'publicType'>
      )>, role: (
        { __typename?: 'Role' }
        & Pick<Role, 'id' | 'name' | 'description' | 'allowedActions'>
      ), favorite: (
        { __typename?: 'Favorite' }
        & Pick<Favorite, 'albumIds' | 'artistIds' | 'trackIds'>
      ) }
    )> }
  )> }
);


export const ChangeFavoritesDocument = gql`
    mutation ChangeFavorites($input: ChangeFavoritesInput!) {
  changeFavorites(input: $input) {
    currentUser {
      id
      name
      username
      registered
      version
      publicInformations {
        id
        publicType
      }
      role {
        id
        name
        description
        allowedActions
      }
      favorite {
        albumIds
        artistIds
        trackIds
      }
    }
  }
}
    `;
export type ChangeFavoritesMutationFn = ApolloReactCommon.MutationFunction<ChangeFavoritesMutation, ChangeFavoritesMutationVariables>;

/**
 * __useChangeFavoritesMutation__
 *
 * To run a mutation, you first call `useChangeFavoritesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useChangeFavoritesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [changeFavoritesMutation, { data, loading, error }] = useChangeFavoritesMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useChangeFavoritesMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<ChangeFavoritesMutation, ChangeFavoritesMutationVariables>) {
        return ApolloReactHooks.useMutation<ChangeFavoritesMutation, ChangeFavoritesMutationVariables>(ChangeFavoritesDocument, baseOptions);
      }
export type ChangeFavoritesMutationHookResult = ReturnType<typeof useChangeFavoritesMutation>;
export type ChangeFavoritesMutationResult = ApolloReactCommon.MutationResult<ChangeFavoritesMutation>;
export type ChangeFavoritesMutationOptions = ApolloReactCommon.BaseMutationOptions<ChangeFavoritesMutation, ChangeFavoritesMutationVariables>;
export const SpotifyTokenDocument = gql`
    query SpotifyToken($code: String, $refreshToken: String) {
  spotifyToken(code: $code, refreshToken: $refreshToken) {
    accessToken
    expiresIn
    refreshToken
    scope
    tokenType
  }
}
    `;

/**
 * __useSpotifyTokenQuery__
 *
 * To run a query within a React component, call `useSpotifyTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSpotifyTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSpotifyTokenQuery({
 *   variables: {
 *      code: // value for 'code'
 *      refreshToken: // value for 'refreshToken'
 *   },
 * });
 */
export function useSpotifyTokenQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<SpotifyTokenQuery, SpotifyTokenQueryVariables>) {
        return ApolloReactHooks.useQuery<SpotifyTokenQuery, SpotifyTokenQueryVariables>(SpotifyTokenDocument, baseOptions);
      }
export function useSpotifyTokenLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<SpotifyTokenQuery, SpotifyTokenQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<SpotifyTokenQuery, SpotifyTokenQueryVariables>(SpotifyTokenDocument, baseOptions);
        }
export type SpotifyTokenQueryHookResult = ReturnType<typeof useSpotifyTokenQuery>;
export type SpotifyTokenLazyQueryHookResult = ReturnType<typeof useSpotifyTokenLazyQuery>;
export type SpotifyTokenQueryResult = ApolloReactCommon.QueryResult<SpotifyTokenQuery, SpotifyTokenQueryVariables>;
export const AlbumDocument = gql`
    query Album($id: TTID!) {
  album(id: $id) {
    id
    totalTracks
    name
    releaseDate
    recordLabel
    copyright
    artworkL {
      url
      width
      height
    }
    artworkM {
      url
      width
      height
    }
    appleMusicAlbum {
      id
      appleMusicId
    }
    itunesAlbum {
      id
      appleMusicId
    }
    spotifyAlbum {
      id
      spotifyId
    }
    tracks {
      id
      isrc
      name
      discNumber
      trackNumber
      durationMs
      previewUrl
      popularity
      artworkM {
        url
        width
        height
      }
      appleMusicTracks {
        id
        name
        appleMusicId
      }
      spotifyTracks {
        id
        name
        spotifyId
      }
    }
  }
}
    `;

/**
 * __useAlbumQuery__
 *
 * To run a query within a React component, call `useAlbumQuery` and pass it any options that fit your needs.
 * When your component renders, `useAlbumQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAlbumQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useAlbumQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<AlbumQuery, AlbumQueryVariables>) {
        return ApolloReactHooks.useQuery<AlbumQuery, AlbumQueryVariables>(AlbumDocument, baseOptions);
      }
export function useAlbumLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<AlbumQuery, AlbumQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<AlbumQuery, AlbumQueryVariables>(AlbumDocument, baseOptions);
        }
export type AlbumQueryHookResult = ReturnType<typeof useAlbumQuery>;
export type AlbumLazyQueryHookResult = ReturnType<typeof useAlbumLazyQuery>;
export type AlbumQueryResult = ApolloReactCommon.QueryResult<AlbumQuery, AlbumQueryVariables>;
export const AlbumsDocument = gql`
    query Albums($cursor: CursorInputObject, $sort: AlbumsSortInputObject, $conditions: AlbumsConditionsInputObject) {
  items: albums(cursor: $cursor, sort: $sort, conditions: $conditions) {
    id
    name
    status
    artworkM {
      url
      width
      height
    }
    appleMusicAlbum {
      id
    }
    itunesAlbum {
      id
    }
    spotifyAlbum {
      id
    }
  }
}
    `;

/**
 * __useAlbumsQuery__
 *
 * To run a query within a React component, call `useAlbumsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAlbumsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAlbumsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      sort: // value for 'sort'
 *      conditions: // value for 'conditions'
 *   },
 * });
 */
export function useAlbumsQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<AlbumsQuery, AlbumsQueryVariables>) {
        return ApolloReactHooks.useQuery<AlbumsQuery, AlbumsQueryVariables>(AlbumsDocument, baseOptions);
      }
export function useAlbumsLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<AlbumsQuery, AlbumsQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<AlbumsQuery, AlbumsQueryVariables>(AlbumsDocument, baseOptions);
        }
export type AlbumsQueryHookResult = ReturnType<typeof useAlbumsQuery>;
export type AlbumsLazyQueryHookResult = ReturnType<typeof useAlbumsLazyQuery>;
export type AlbumsQueryResult = ApolloReactCommon.QueryResult<AlbumsQuery, AlbumsQueryVariables>;
export const AppleMusicTokenDocument = gql`
    query AppleMusicToken {
  appleMusicToken
}
    `;

/**
 * __useAppleMusicTokenQuery__
 *
 * To run a query within a React component, call `useAppleMusicTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useAppleMusicTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAppleMusicTokenQuery({
 *   variables: {
 *   },
 * });
 */
export function useAppleMusicTokenQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<AppleMusicTokenQuery, AppleMusicTokenQueryVariables>) {
        return ApolloReactHooks.useQuery<AppleMusicTokenQuery, AppleMusicTokenQueryVariables>(AppleMusicTokenDocument, baseOptions);
      }
export function useAppleMusicTokenLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<AppleMusicTokenQuery, AppleMusicTokenQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<AppleMusicTokenQuery, AppleMusicTokenQueryVariables>(AppleMusicTokenDocument, baseOptions);
        }
export type AppleMusicTokenQueryHookResult = ReturnType<typeof useAppleMusicTokenQuery>;
export type AppleMusicTokenLazyQueryHookResult = ReturnType<typeof useAppleMusicTokenLazyQuery>;
export type AppleMusicTokenQueryResult = ApolloReactCommon.QueryResult<AppleMusicTokenQuery, AppleMusicTokenQueryVariables>;
export const ArtistDocument = gql`
    query Artist($id: TTID!) {
  artist(id: $id) {
    id
    name
    artworkL {
      url
      width
      height
    }
  }
}
    `;

/**
 * __useArtistQuery__
 *
 * To run a query within a React component, call `useArtistQuery` and pass it any options that fit your needs.
 * When your component renders, `useArtistQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArtistQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useArtistQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<ArtistQuery, ArtistQueryVariables>) {
        return ApolloReactHooks.useQuery<ArtistQuery, ArtistQueryVariables>(ArtistDocument, baseOptions);
      }
export function useArtistLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<ArtistQuery, ArtistQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<ArtistQuery, ArtistQueryVariables>(ArtistDocument, baseOptions);
        }
export type ArtistQueryHookResult = ReturnType<typeof useArtistQuery>;
export type ArtistLazyQueryHookResult = ReturnType<typeof useArtistLazyQuery>;
export type ArtistQueryResult = ApolloReactCommon.QueryResult<ArtistQuery, ArtistQueryVariables>;
export const ArtistsDocument = gql`
    query Artists($cursor: CursorInputObject, $sort: ArtistsSortInputObject, $conditions: ArtistsConditionsInputObject) {
  items: artists(cursor: $cursor, sort: $sort, conditions: $conditions) {
    id
    name
    status
    artworkM {
      url
      width
      height
    }
  }
}
    `;

/**
 * __useArtistsQuery__
 *
 * To run a query within a React component, call `useArtistsQuery` and pass it any options that fit your needs.
 * When your component renders, `useArtistsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useArtistsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      sort: // value for 'sort'
 *      conditions: // value for 'conditions'
 *   },
 * });
 */
export function useArtistsQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<ArtistsQuery, ArtistsQueryVariables>) {
        return ApolloReactHooks.useQuery<ArtistsQuery, ArtistsQueryVariables>(ArtistsDocument, baseOptions);
      }
export function useArtistsLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<ArtistsQuery, ArtistsQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<ArtistsQuery, ArtistsQueryVariables>(ArtistsDocument, baseOptions);
        }
export type ArtistsQueryHookResult = ReturnType<typeof useArtistsQuery>;
export type ArtistsLazyQueryHookResult = ReturnType<typeof useArtistsLazyQuery>;
export type ArtistsQueryResult = ApolloReactCommon.QueryResult<ArtistsQuery, ArtistsQueryVariables>;
export const PlaylistDocument = gql`
    query Playlist($id: TTID!) {
  playlist(id: $id) {
    id
    name
    description
    track {
      id
      artworkL {
        url
        width
        height
      }
    }
    author {
      id
      name
      username
    }
    publicType
    createdAt
    updatedAt
    items {
      trackNumber
      track {
        id
        isrc
        name
        discNumber
        trackNumber
        durationMs
        previewUrl
        popularity
        artworkM {
          url
          width
          height
        }
        appleMusicTracks {
          id
          name
          appleMusicId
        }
        spotifyTracks {
          id
          name
          spotifyId
        }
      }
    }
  }
}
    `;

/**
 * __usePlaylistQuery__
 *
 * To run a query within a React component, call `usePlaylistQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaylistQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaylistQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function usePlaylistQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<PlaylistQuery, PlaylistQueryVariables>) {
        return ApolloReactHooks.useQuery<PlaylistQuery, PlaylistQueryVariables>(PlaylistDocument, baseOptions);
      }
export function usePlaylistLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<PlaylistQuery, PlaylistQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<PlaylistQuery, PlaylistQueryVariables>(PlaylistDocument, baseOptions);
        }
export type PlaylistQueryHookResult = ReturnType<typeof usePlaylistQuery>;
export type PlaylistLazyQueryHookResult = ReturnType<typeof usePlaylistLazyQuery>;
export type PlaylistQueryResult = ApolloReactCommon.QueryResult<PlaylistQuery, PlaylistQueryVariables>;
export const PlaylistsDocument = gql`
    query Playlists($cursor: CursorInputObject, $sort: PlaylistsSortInputObject, $conditions: PlaylistsConditionsInputObject) {
  items: playlists(cursor: $cursor, sort: $sort, conditions: $conditions) {
    id
    name
    track {
      id
      artworkM {
        url
        width
        height
      }
    }
    author {
      id
      name
    }
    createdAt
    updatedAt
  }
}
    `;

/**
 * __usePlaylistsQuery__
 *
 * To run a query within a React component, call `usePlaylistsQuery` and pass it any options that fit your needs.
 * When your component renders, `usePlaylistsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePlaylistsQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      sort: // value for 'sort'
 *      conditions: // value for 'conditions'
 *   },
 * });
 */
export function usePlaylistsQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<PlaylistsQuery, PlaylistsQueryVariables>) {
        return ApolloReactHooks.useQuery<PlaylistsQuery, PlaylistsQueryVariables>(PlaylistsDocument, baseOptions);
      }
export function usePlaylistsLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<PlaylistsQuery, PlaylistsQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<PlaylistsQuery, PlaylistsQueryVariables>(PlaylistsDocument, baseOptions);
        }
export type PlaylistsQueryHookResult = ReturnType<typeof usePlaylistsQuery>;
export type PlaylistsLazyQueryHookResult = ReturnType<typeof usePlaylistsLazyQuery>;
export type PlaylistsQueryResult = ApolloReactCommon.QueryResult<PlaylistsQuery, PlaylistsQueryVariables>;
export const TracksDocument = gql`
    query Tracks($cursor: CursorInputObject, $sort: TracksSortInputObject, $conditions: TracksConditionsInputObject) {
  items: tracks(cursor: $cursor, sort: $sort, conditions: $conditions) {
    id
    isrc
    name
    discNumber
    trackNumber
    durationMs
    previewUrl
    popularity
    appleMusicTracks {
      id
    }
    itunesTracks {
      id
    }
    spotifyTracks {
      id
    }
    artworkM {
      url
      width
      height
    }
  }
}
    `;

/**
 * __useTracksQuery__
 *
 * To run a query within a React component, call `useTracksQuery` and pass it any options that fit your needs.
 * When your component renders, `useTracksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTracksQuery({
 *   variables: {
 *      cursor: // value for 'cursor'
 *      sort: // value for 'sort'
 *      conditions: // value for 'conditions'
 *   },
 * });
 */
export function useTracksQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<TracksQuery, TracksQueryVariables>) {
        return ApolloReactHooks.useQuery<TracksQuery, TracksQueryVariables>(TracksDocument, baseOptions);
      }
export function useTracksLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<TracksQuery, TracksQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<TracksQuery, TracksQueryVariables>(TracksDocument, baseOptions);
        }
export type TracksQueryHookResult = ReturnType<typeof useTracksQuery>;
export type TracksLazyQueryHookResult = ReturnType<typeof useTracksLazyQuery>;
export type TracksQueryResult = ApolloReactCommon.QueryResult<TracksQuery, TracksQueryVariables>;
export const LoginDocument = gql`
    mutation Login($input: LoginInput!) {
  login(input: $input) {
    currentUser {
      id
      name
      username
      registered
      version
      publicInformations {
        id
        publicType
      }
      role {
        id
        name
        description
        allowedActions
      }
      favorite {
        albumIds
        artistIds
        trackIds
      }
    }
    error
  }
}
    `;
export type LoginMutationFn = ApolloReactCommon.MutationFunction<LoginMutation, LoginMutationVariables>;

/**
 * __useLoginMutation__
 *
 * To run a mutation, you first call `useLoginMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLoginMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [loginMutation, { data, loading, error }] = useLoginMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLoginMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<LoginMutation, LoginMutationVariables>) {
        return ApolloReactHooks.useMutation<LoginMutation, LoginMutationVariables>(LoginDocument, baseOptions);
      }
export type LoginMutationHookResult = ReturnType<typeof useLoginMutation>;
export type LoginMutationResult = ApolloReactCommon.MutationResult<LoginMutation>;
export type LoginMutationOptions = ApolloReactCommon.BaseMutationOptions<LoginMutation, LoginMutationVariables>;
export const LogoutDocument = gql`
    mutation Logout($input: LogoutInput!) {
  logout(input: $input) {
    currentUser {
      id
      name
      username
      registered
      version
      publicInformations {
        id
        publicType
      }
      role {
        id
        name
        description
        allowedActions
      }
      favorite {
        albumIds
        artistIds
        trackIds
      }
    }
    error
  }
}
    `;
export type LogoutMutationFn = ApolloReactCommon.MutationFunction<LogoutMutation, LogoutMutationVariables>;

/**
 * __useLogoutMutation__
 *
 * To run a mutation, you first call `useLogoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useLogoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [logoutMutation, { data, loading, error }] = useLogoutMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useLogoutMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<LogoutMutation, LogoutMutationVariables>) {
        return ApolloReactHooks.useMutation<LogoutMutation, LogoutMutationVariables>(LogoutDocument, baseOptions);
      }
export type LogoutMutationHookResult = ReturnType<typeof useLogoutMutation>;
export type LogoutMutationResult = ApolloReactCommon.MutationResult<LogoutMutation>;
export type LogoutMutationOptions = ApolloReactCommon.BaseMutationOptions<LogoutMutation, LogoutMutationVariables>;
export const MeDocument = gql`
    query Me {
  me {
    id
    name
    username
    registered
    version
    publicInformations {
      id
      publicType
    }
    role {
      id
      name
      description
      allowedActions
    }
    favorite {
      albumIds
      artistIds
      trackIds
    }
  }
}
    `;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: ApolloReactHooks.QueryHookOptions<MeQuery, MeQueryVariables>) {
        return ApolloReactHooks.useQuery<MeQuery, MeQueryVariables>(MeDocument, baseOptions);
      }
export function useMeLazyQuery(baseOptions?: ApolloReactHooks.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          return ApolloReactHooks.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, baseOptions);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = ApolloReactCommon.QueryResult<MeQuery, MeQueryVariables>;
export const UpdateMeDocument = gql`
    mutation UpdateMe($input: UpdateMeInput!) {
  updateMe(input: $input) {
    currentUser {
      id
      name
      username
      registered
      version
      publicInformations {
        id
        publicType
      }
      role {
        id
        name
        description
        allowedActions
      }
      favorite {
        albumIds
        artistIds
        trackIds
      }
    }
    error
  }
}
    `;
export type UpdateMeMutationFn = ApolloReactCommon.MutationFunction<UpdateMeMutation, UpdateMeMutationVariables>;

/**
 * __useUpdateMeMutation__
 *
 * To run a mutation, you first call `useUpdateMeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateMeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateMeMutation, { data, loading, error }] = useUpdateMeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateMeMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<UpdateMeMutation, UpdateMeMutationVariables>) {
        return ApolloReactHooks.useMutation<UpdateMeMutation, UpdateMeMutationVariables>(UpdateMeDocument, baseOptions);
      }
export type UpdateMeMutationHookResult = ReturnType<typeof useUpdateMeMutation>;
export type UpdateMeMutationResult = ApolloReactCommon.MutationResult<UpdateMeMutation>;
export type UpdateMeMutationOptions = ApolloReactCommon.BaseMutationOptions<UpdateMeMutation, UpdateMeMutationVariables>;
export const SignupDocument = gql`
    mutation Signup($input: SignupInput!) {
  signup(input: $input) {
    currentUser {
      id
      name
      username
      registered
      version
      publicInformations {
        id
        publicType
      }
      role {
        id
        name
        description
        allowedActions
      }
      favorite {
        albumIds
        artistIds
        trackIds
      }
    }
    error
  }
}
    `;
export type SignupMutationFn = ApolloReactCommon.MutationFunction<SignupMutation, SignupMutationVariables>;

/**
 * __useSignupMutation__
 *
 * To run a mutation, you first call `useSignupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSignupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [signupMutation, { data, loading, error }] = useSignupMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useSignupMutation(baseOptions?: ApolloReactHooks.MutationHookOptions<SignupMutation, SignupMutationVariables>) {
        return ApolloReactHooks.useMutation<SignupMutation, SignupMutationVariables>(SignupDocument, baseOptions);
      }
export type SignupMutationHookResult = ReturnType<typeof useSignupMutation>;
export type SignupMutationResult = ApolloReactCommon.MutationResult<SignupMutation>;
export type SignupMutationOptions = ApolloReactCommon.BaseMutationOptions<SignupMutation, SignupMutationVariables>;